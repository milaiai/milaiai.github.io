<!DOCTYPE html>
<html lang="en"><head>


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-131527698-4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-131527698-4');
</script>

<title>MILAI AI | 算法-最短路径</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
    <meta name="description" content="MILAI AI">
    
    <meta name="description" content="最短路径">
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
    <link rel="manifest" href="/favicon/site.webmanifest" />
    <link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#5bbad5" />
    <link rel="shortcut icon" href="/favicon/favicon.ico" />
    <meta name="theme-color" content="#ffffff">
    <meta property="og:title" content="MILAI AI | 算法-最短路径" />
    
    
        
        <link rel="stylesheet" href="https://milaiai.com/css/styles.min.dec565c82e7132ba8a26716cb3139764f5f7b34ef0b64ef1ee5bcb2a082e7438.css" integrity="sha256-3sVlyC5xMrqKJnFssxOXZPX3s07wtk7x7lvLKggudDg=">
    
    <link id="dark-mode-theme" rel="stylesheet" href="/css/darker.min.css" async disabled>
    <link href="/css/blonde.min.css" rel="stylesheet" type="text/css" media="print"
        onload="this.media='all'">
    



<meta name="description" content="最短路径">
<meta property="og:site_name" content="MILAI AI">
<meta property="og:description" content="最短路径">
<meta property="og:url" content="https://milaiai.com/post/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/">
<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="">

<link rel="canonical" href="https://milaiai.com/post/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/">

<meta name="twitter:description" content="最短路径">
<meta property="article:published_time" content="2019-03-10T00:00:00&#43;00:00">
<meta property="article:updated_time" content="2019-03-10T00:00:00&#43;00:00">





    
<meta property="og:image" content="https://milaiai.com/img/cover.jpg">
<meta property="og:image:url" content="https://milaiai.com/img/cover.jpg">
    

    
</head>
<body class="font-sans">
    <div class="min-h-screen flex flex-col bg-gray-100"><div class="bg-gray-800">
    <div class="container mr-auto ml-auto">
        <nav class="flex items-center justify-between flex-wrap bg-gray-800 p-6">
            <div class="flex items-center flex-no-shrink bg-gray-800 text-white mr-6">
                <a href="https://milaiai.com/"><span
                        class="font-semibold text-2xl tracking-tight">MILAI AI</span></a>
            </div>
            <div class="flex md:hidden">
                <div class="py-2">
                    <a id="dark-mode-toggle-1" href="javascript:void(0);" class="no-underline text-white mr-2"><span
                            id="dark-mode-toggle-icon1"
                            class="icon-moon inline-flex align-middle leading-normal text-lg mr-2" aria-label="Darkmode Toggle Button"></span></a>
                    <span class="text-gray-300">|</span>
                </div>
                <button id="hamburgerbtn"
                    class="flex items-center px-3 py-1 text-gray-300 hover:text-white">
                    <span class="icon-menu text-2xl" aria-label="Hamburger Button"></span>
                </button>
            </div>
            <div class="hidden w-full md:flex md:flex-row sm:items-center md:w-auto" id="mobileMenu">
                <div class="text-sm lg:flex-grow">
                </div>
                <div class="navmenu">
                    
                    <a href="/"
                        class="no-underline block mt-4 sm:inline-block sm:mt-0 text-gray-400 hover:text-white mr-4">
                        Home
                    </a>
                    
                    <a href="/about/"
                        class="no-underline block mt-4 sm:inline-block sm:mt-0 text-gray-400 hover:text-white mr-4">
                        About
                    </a>
                    
                    <a href="/contact/"
                        class="no-underline block mt-4 sm:inline-block sm:mt-0 text-gray-400 hover:text-white mr-4">
                        Contact
                    </a>
                    
                </div>
                <div class="text-gray-400 invisible md:visible">
                    <span>|</span>
                    <a id="dark-mode-toggle-2" href="javascript:void(0);" class="no-underline hover:text-white"><span
                            id="dark-mode-toggle-icon2"
                            class="icon-moon inline-flex align-middle leading-normal text-lg mr-2"></span></a>
                </div>
            </div>
        </nav>
    </div>
</div>
<style>
    .active {
        display: block;
    }
</style>
<script>
    let hamburger = document.getElementById('hamburgerbtn');

    let mobileMenu = document.getElementById('mobileMenu');

    hamburger.addEventListener('click', function () {
        mobileMenu.classList.toggle('active');
    });
</script>
<div class="container mx-auto mt-4 flex-grow" id="content">
            <div class="lg:mx-5">
<div class="grid grid-cols-3 gap-4">
    
    <div class="col-span-3 dark:text-white">
    
        <div class="bg-white dark:bg-warmgray-900 p-5 my-4">
            <h1 class="title text-4xl">算法-最短路径</h1>
            <hr class="my-2">
            <aside id="meta">
                <div>
                    <section>
                        <h4 id="date"><span class="icon-access_time mr-2"></span>2019/03/10 </h4>
                    </section>
                    
                    <div id="tags">
                        <span class="icon-local_offer mr-1"></span>
                        
                        <a href="https://milaiai.com/tags/algorithm">Algorithm</a> |
                        
                    </div>
                    
                </div>
            </aside>
            <hr class="my-2">
            
            <img class="py-4" src="https://milaiai.com/img/cover.jpg">
            
            <div class="content mt-5"><h1 id="最短路径">最短路径</h1>
<h2 id="dijkstra-算法">Dijkstra 算法</h2>
<p>基于贪心的单源最短路算法，其要求图中的边全部非负。</p>
<ul>
<li>
<p><a href="https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/">Dijkstra’s shortest path algorithm</a></p>
</li>
<li>
<p><a href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95">戴克斯特拉算法-wiki</a></p>
</li>
</ul>
<h3 id="算法描述">算法描述</h3>
<p>procedure Dijkstra(G：边全为正权的图）
2   {G带有顶点 $a=v_{0},v_{1},v_{2}&hellip;$}和若干边 $w(v_{i},v_{j})$
3    for  i:=1 to n
4       $D(v_{i}):=\infty $
5   D(a):=0
6  $S:=\emptyset$
7    while $z\notin S$
8    begin
9   	 u:=不属于S的D(u)最小的一个顶点
10  	 $S:=S\cup {u}$
11    	for 所有不属于S的顶点v
12         	if  D(u)+w(u,v)&lt;D(v) then D(v):=D(u)+w(u,v)
13    end{D(z)=从a到z的最短路长度}</p>
<p>使用优先队列</p>
<p>1  function Dijkstra(G, w, s)
2   INITIALIZE-SINGLE-SOURCE(G, s)                //实际上的操作是将每个除原点外的顶点的d[v]置为无穷大，d[s]=0
3  $S\leftarrow \emptyset$
4  $Q\leftarrow s$                      // Q是顶点V的一个优先队列，以顶点的最短路径估计排序
5   while( $Q\not =\emptyset $)
6       do $u\leftarrow EXTRACT-MIN(Q)$          //选取u为Q中最短路径估计最小的顶点
7     	$S\leftarrow S\cup u$
8      	for each vertex $v \in Adj[u]$
9            do RELAX(u, v, w)            //松弛成功的结点会被加入到队列中</p>
<p><a href="http://codeforces.com/blog/entry/16221">http://codeforces.com/blog/entry/16221</a> :</p>
<p>Pseudo code :</p>
<pre tabindex="0"><code>dijkstra(v) :
        d[i] = inf for each vertex i
        d[v] = 0
        s = new empty set
        while s.size() &lt; n
                x = inf
                u = -1
                for each i in V-s //V is the set of vertices
                        if x &gt;= d[i]
                                then x = d[i], u = i
                insert u into s
                // The process from now is called Relaxing
                for each i in adj[u]
                        d[i] = min(d[i], d[u] + w(u,i))
                        
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> mark[MAXN];
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dijkstra</span>(<span style="color:#66d9ef">int</span> v){
	fill(d,d <span style="color:#f92672">+</span> n, inf);
	fill(mark, mark <span style="color:#f92672">+</span> n, false);
	d[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">int</span> u;
	<span style="color:#66d9ef">while</span>(true){
		<span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> inf;
		u <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> n;i <span style="color:#f92672">++</span>)
			<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>mark[i] and x <span style="color:#f92672">&gt;=</span> d[i])
				x <span style="color:#f92672">=</span> d[i], u <span style="color:#f92672">=</span> i;
		<span style="color:#66d9ef">if</span>(u <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)	<span style="color:#66d9ef">break</span>;
		mark[u] <span style="color:#f92672">=</span> true;
		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> p : adj[u]) <span style="color:#75715e">//adj[v][i] = pair(vertex, weight)
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span>(d[p.first] <span style="color:#f92672">&gt;</span> d[u] <span style="color:#f92672">+</span> p.second)
				d[p.first] <span style="color:#f92672">=</span> d[u] <span style="color:#f92672">+</span> p.second;
	}
}
</code></pre></div><p>Two) <img src="https://espresso.codeforces.com/8be993eafecdfb87ed795da91da8626cc7b54983.png" alt="img"></p>
<ol>
<li>Using <code>std :: set</code> :</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dijkstra</span>(<span style="color:#66d9ef">int</span> v){
	fill(d,d <span style="color:#f92672">+</span> n, inf);
	d[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">int</span> u;
	set<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> s;
	s.insert({d[v], v});
	<span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>s.empty()){
		u <span style="color:#f92672">=</span> s.begin() <span style="color:#f92672">-&gt;</span> second;
		s.erase(s.begin());
		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> p : adj[u]) <span style="color:#75715e">//adj[v][i] = pair(vertex, weight)
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span>(d[p.first] <span style="color:#f92672">&gt;</span> d[u] <span style="color:#f92672">+</span> p.second){
				s.erase({d[p.first], p.first});
				d[p.first] <span style="color:#f92672">=</span> d[u] <span style="color:#f92672">+</span> p.second;
				s.insert({d[p.first], p.first});
			}
	}
}
</code></pre></div><ol start="2">
<li>Using <code>std :: priority_queue</code> (better):</li>
</ol>
<pre tabindex="0"><code>bool mark[MAXN];
void dijkstra(int v){
	fill(d,d + n, inf);
	fill(mark, mark + n, false);
	d[v] = 0;
	int u;
	priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;, greater&lt;pair&lt;int,int&gt; &gt; &gt; pq;
	pq.push({d[v], v});
	while(!pq.empty()){
		u = pq.top().second;
		pq.pop();
		if(mark[u])
			continue;
		mark[u] = true;
		for(auto p : adj[u]) //adj[v][i] = pair(vertex, weight)
			if(d[p.first] &gt; d[u] + p.second){
				d[p.first] = d[u] + p.second;
				pq.push({d[p.first], p.first});
			}
	}
}
</code></pre><p>Problem: <a href="http://codeforces.com/gym/100571/problem/D">ShortestPath Query</a></p>
<h3 id="implement-1">Implement 1</h3>
<p><img src="https://www.geeksforgeeks.org/wp-content/uploads/Fig-11.jpg" alt=""></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// A C++ program for Dijkstra&#39;s single source shortest path algorithm.
</span><span style="color:#75715e">// The program is for adjacency matrix representation of the graph
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;limits.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Number of vertices in the graph
</span><span style="color:#75715e"></span><span style="color:#75715e">#define V 9
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// A utility function to find the vertex with minimum distance value, from
</span><span style="color:#75715e">// the set of vertices not yet included in shortest path tree
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">minDistance</span>(<span style="color:#66d9ef">int</span> dist[], <span style="color:#66d9ef">bool</span> sptSet[])
{

	<span style="color:#75715e">// Initialize min value
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> INT_MAX, min_index;

	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; v <span style="color:#f92672">&lt;</span> V; v<span style="color:#f92672">++</span>)
		<span style="color:#66d9ef">if</span> (sptSet[v] <span style="color:#f92672">==</span> false <span style="color:#f92672">&amp;&amp;</span> dist[v] <span style="color:#f92672">&lt;=</span> min)
			min <span style="color:#f92672">=</span> dist[v], min_index <span style="color:#f92672">=</span> v;

	<span style="color:#66d9ef">return</span> min_index;
}

<span style="color:#75715e">// A utility function to print the constructed distance array
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printSolution</span>(<span style="color:#66d9ef">int</span> dist[])
{
	cout <span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;Vertex </span><span style="color:#ae81ff">\t</span><span style="color:#e6db74"> Distance from Source&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> V; i<span style="color:#f92672">++</span>)
		cout <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; </span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">&lt;&lt;</span>dist[i]<span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#75715e">// Function that implements Dijkstra&#39;s single source shortest path algorithm
</span><span style="color:#75715e">// for a graph represented using adjacency matrix representation
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dijkstra</span>(<span style="color:#66d9ef">int</span> graph[V][V], <span style="color:#66d9ef">int</span> src)
{
	<span style="color:#66d9ef">int</span> dist[V]; <span style="color:#75715e">// The output array. dist[i] will hold the shortest
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// distance from src to i
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">bool</span> sptSet[V]; <span style="color:#75715e">// sptSet[i] will be true if vertex i is included in shortest
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// path tree or shortest distance from src to i is finalized
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// Initialize all distances as INFINITE and stpSet[] as false
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> V; i<span style="color:#f92672">++</span>)
		dist[i] <span style="color:#f92672">=</span> INT_MAX, sptSet[i] <span style="color:#f92672">=</span> false;

	<span style="color:#75715e">// Distance of source vertex from itself is always 0
</span><span style="color:#75715e"></span>	dist[src] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

	<span style="color:#75715e">// Find shortest path for all vertices
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; count <span style="color:#f92672">&lt;</span> V <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; count<span style="color:#f92672">++</span>) {
		<span style="color:#75715e">// Pick the minimum distance vertex from the set of vertices not
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// yet processed. u is always equal to src in the first iteration.
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> minDistance(dist, sptSet);

		<span style="color:#75715e">// Mark the picked vertex as processed
</span><span style="color:#75715e"></span>		sptSet[u] <span style="color:#f92672">=</span> true;

		<span style="color:#75715e">// Update dist value of the adjacent vertices of the picked vertex.
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; v <span style="color:#f92672">&lt;</span> V; v<span style="color:#f92672">++</span>)

			<span style="color:#75715e">// Update dist[v] only if is not in sptSet, there is an edge from
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// u to v, and total weight of path from src to v through u is
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// smaller than current value of dist[v]
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>sptSet[v] <span style="color:#f92672">&amp;&amp;</span> graph[u][v] <span style="color:#f92672">&amp;&amp;</span> dist[u] <span style="color:#f92672">!=</span> INT_MAX
				<span style="color:#f92672">&amp;&amp;</span> dist[u] <span style="color:#f92672">+</span> graph[u][v] <span style="color:#f92672">&lt;</span> dist[v])
				dist[v] <span style="color:#f92672">=</span> dist[u] <span style="color:#f92672">+</span> graph[u][v];
	}

	<span style="color:#75715e">// print the constructed distance array
</span><span style="color:#75715e"></span>	printSolution(dist);
}

<span style="color:#75715e">// driver program to test above function
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{

	<span style="color:#75715e">/* Let us create the example graph discussed above */</span>
	<span style="color:#66d9ef">int</span> graph[V][V] <span style="color:#f92672">=</span> { { <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">0</span> },
						{ <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">0</span> },
						{ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span> },
						{ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span> },
						{ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span> },
						{ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span> },
						{ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">6</span> },
						{ <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">7</span> },
						{ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">0</span> } };

	dijkstra(graph, <span style="color:#ae81ff">0</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// This code is contributed by shivanisinghss2110
</span></code></pre></div><h3 id="implement-2-priority_queue">Implement 2: priority_queue</h3>
<p>priority_queue 模板有 3 个参数，其中两个有默认的参数；第一个参数是存储对象的类型，第二个参数是存储元素的底层容器，第三个参数是函数对象，它定义了一个用来决定元素顺序的断言。因此模板类型是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span> Container<span style="color:#f92672">=</span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>, <span style="color:#66d9ef">typename</span> Compare<span style="color:#f92672">=</span>std<span style="color:#f92672">::</span>less<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">priority_queue</span>
</code></pre></div><p>如你所见，priority_queue 实例默认有一个 vector 容器。函数对象类型 less<T> 是一个默认的排序断言，定义在头文件 function 中，决定了容器中最大的元素会排在队列前面。fonction 中定义了  greater<T>，用来作为模板的最后一个参数对元素排序，最小元素会排在队列前面。当然，如果指定模板的最巵一个参数，就必须提供另外的两个模板类型参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;bits/stdc++.h&gt; </span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std; 
<span style="color:#75715e"># define INF 0x3f3f3f3f 
</span><span style="color:#75715e"></span>  
<span style="color:#75715e">// iPair ==&gt; Integer Pair（整数对）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> iPair; 
  
<span style="color:#75715e">// 加边
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addEdge</span>(vector <span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> adj[], <span style="color:#66d9ef">int</span> u, 
                                     <span style="color:#66d9ef">int</span> v, <span style="color:#66d9ef">int</span> wt) 
{ 
    adj[u].push_back(make_pair(v, wt)); 
    adj[v].push_back(make_pair(u, wt)); 
} 
   
  
<span style="color:#75715e">// 计算最短路
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">shortestPath</span>(vector<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> adj[], <span style="color:#66d9ef">int</span> V, <span style="color:#66d9ef">int</span> src) 
{ 
    <span style="color:#75715e">// 关于stl中的优先队列如何实现，参考下方网址：
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// http://geeksquiz.com/implement-min-heap-using-stl/ 
</span><span style="color:#75715e"></span>    priority_queue<span style="color:#f92672">&lt;</span> iPair, vector <span style="color:#f92672">&lt;</span>iPair<span style="color:#f92672">&gt;</span> , greater<span style="color:#f92672">&lt;</span>iPair<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> pq; 
  
    <span style="color:#75715e">// 距离置为正无穷大
</span><span style="color:#75715e"></span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dist(V, INF); 
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> visited(V, false);

    <span style="color:#75715e">// 插入源点，距离为0
</span><span style="color:#75715e"></span>    pq.push(make_pair(<span style="color:#ae81ff">0</span>, src)); 
    dist[src] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
  
    <span style="color:#75715e">/* 循环直到优先队列为空 */</span>
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>pq.empty()) 
    { 
        <span style="color:#75715e">// 每次从优先队列中取出顶点事实上是这一轮最短路径权值确定的点
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> pq.top().second; 
        pq.pop(); 
        <span style="color:#66d9ef">if</span> (visited[u]) {
            <span style="color:#66d9ef">continue</span>;
        }
        visited[u] <span style="color:#f92672">=</span> true;
        <span style="color:#75715e">// 遍历所有边
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> x : adj[u]) 
        { 
            <span style="color:#75715e">// 得到顶点边号以及边权
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> x.first; 
            <span style="color:#66d9ef">int</span> weight <span style="color:#f92672">=</span> x.second; 
  
            <span style="color:#75715e">//可以松弛
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (dist[v] <span style="color:#f92672">&gt;</span> dist[u] <span style="color:#f92672">+</span> weight) 
            { 
                <span style="color:#75715e">// 松弛 
</span><span style="color:#75715e"></span>                dist[v] <span style="color:#f92672">=</span> dist[u] <span style="color:#f92672">+</span> weight; 
                pq.push(make_pair(dist[v], v)); 
            } 
        } 
    } 
  
    <span style="color:#75715e">// 打印最短路
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;Vertex Distance from Source</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> V; <span style="color:#f92672">++</span>i) 
        printf(<span style="color:#e6db74">&#34;%d </span><span style="color:#ae81ff">\t\t</span><span style="color:#e6db74"> %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, dist[i]); 
} 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() 
{ 
    <span style="color:#66d9ef">int</span> V <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>; 
    vector<span style="color:#f92672">&lt;</span>iPair <span style="color:#f92672">&gt;</span> adj[V]; 
    addEdge(adj, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>); 
    addEdge(adj, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>); 
    addEdge(adj, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">8</span>); 
    addEdge(adj, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">11</span>); 
    addEdge(adj, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>); 
    addEdge(adj, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">2</span>); 
    addEdge(adj, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>); 
    addEdge(adj, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">9</span>); 
    addEdge(adj, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">14</span>); 
    addEdge(adj, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">10</span>); 
    addEdge(adj, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">2</span>); 
    addEdge(adj, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">1</span>); 
    addEdge(adj, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">6</span>); 
    addEdge(adj, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">7</span>); 
  
    shortestPath(adj, V, <span style="color:#ae81ff">0</span>); 
  
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; 
}
</code></pre></div><h3 id="p4779-单源最短路径httpswwwluogucomcnproblemp4779"><a href="https://www.luogu.com.cn/problem/P4779">P4779 单源最短路径</a></h3>
<p>给定一个 n 个点，m 条有向边的带非负权图，请你计算从 s 出发，到每个点的距离。</p>
<p>数据保证你能从 s 出发到任意点。</p>
<h2 id="floyd">Floyd</h2>
<p>是一种基于动态规划的多源最短路算法</p>
<pre tabindex="0"><code>Floyd-Warshal()
	d[v][u] = inf for each pair (v,u)
	d[v][v] = 0 for each vertex v
	for k = 1 to n
		for i = 1 to n
			for j = 1 to n
				d[i][j] = min(d[i][j], d[i][k] + d[k][j])
</code></pre><p>Time complexity : <em>O</em>(<em>n</em>3).</p>
<h2 id="bellman-ford">Bellman-Ford</h2>
<p>不仅可以处理负权边，还能处理负环</p>
<p>对所有的点进行V-1次松弛操作,理论上就找到了从源点到其他所有点的最短路径.</p>
<p>如果还可以继续松弛, 说明原图中有环.</p>
<p>其优于<a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E7%A7%91%E6%96%AF%E5%BD%BB%E7%AE%97%E6%B3%95">迪科斯彻算法</a>的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达O(|V||E|)</p>
<p>贝尔曼-福特算法简单地对所有边进行松弛操作，共|V|-1次，其中|V|是图的点的数量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">procedure BellmanFord(list vertices, list edges, vertex source)
   <span style="color:#f92672">//</span> 讀入邊和節點的列表並對distance和predecessor寫入最短路徑

   <span style="color:#f92672">//</span> 初始化圖
   <span style="color:#66d9ef">for</span> each vertex v <span style="color:#f92672">in</span> vertices:
       <span style="color:#66d9ef">if</span> v <span style="color:#f92672">is</span> source then distance[v] <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
       <span style="color:#66d9ef">else</span> distance[v] <span style="color:#f92672">:=</span> infinity
       predecessor[v] <span style="color:#f92672">:=</span> null

   <span style="color:#f92672">//</span> 對每一條邊重複操作
   <span style="color:#66d9ef">for</span> i <span style="color:#f92672">from</span> <span style="color:#ae81ff">1</span> to size(vertices)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
       <span style="color:#66d9ef">for</span> each edge (u, v) <span style="color:#66d9ef">with</span> weight w <span style="color:#f92672">in</span> edges:
           <span style="color:#66d9ef">if</span> distance[u] <span style="color:#f92672">+</span> w <span style="color:#f92672">&lt;</span> distance[v]:
               distance[v] <span style="color:#f92672">:=</span> distance[u] <span style="color:#f92672">+</span> w
               predecessor[v] <span style="color:#f92672">:=</span> u

   <span style="color:#f92672">//</span> 檢查是否有負權重的回路
   <span style="color:#66d9ef">for</span> each edge (u, v) <span style="color:#66d9ef">with</span> weight w <span style="color:#f92672">in</span> edges:
       <span style="color:#66d9ef">if</span> distance[u] <span style="color:#f92672">+</span> w <span style="color:#f92672">&lt;</span> distance[v]:
           error <span style="color:#e6db74">&#34;圖包含負權重的回路&#34;</span>
</code></pre></div><p><a href="http://codeforces.com/blog/entry/16221">http://codeforces.com/blog/entry/16221</a> :</p>
<pre tabindex="0"><code>Bellman-Ford(int v)
	d[i] = inf for each vertex i
	d[v] = 0
	for step = 1 to n
		for all edges like e
			i = e.first // first end
			j = e.second // second end
			w = e.weight
			if d[j] &gt; d[i] + w
				if step == n
					then return &quot;Negative cycle found&quot;
				d[j] = d[i] + w
</code></pre><p>Time complexity : <em>O</em>(<em>nm</em>).</p>
<h2 id="spfa-shortest-path-faster-algorithm">SPFA (Shortest Path Faster Algorithm)</h2>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%BF%AB%E9%80%9F%E7%AE%97%E6%B3%95">https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%BF%AB%E9%80%9F%E7%AE%97%E6%B3%95</a></li>
</ul>
<p>国际上一般认为是队列优化的<a href="https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E6%9B%BC-%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95">Bellman-Ford 算法</a></p>
<p>这里的<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8752c7023b4b3286800fe3238271bbca681219ed" alt="{\displaystyle Q}">是一个备选节点的先进先出队列，<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c820425919af804281a4d42c9798951ba8f76140" alt="{\displaystyle w(u,v)}"> 是边<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/eadf12294edccd7a29c99cfc1765e4a14bf47e58" alt="{\displaystyle (u,v)}">的权值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"> procedure Shortest-Path-Faster-Algorithm<span style="color:#f92672">(</span>G, s<span style="color:#f92672">)</span>
      <span style="color:#66d9ef">for</span> each vertex v ≠ s in V<span style="color:#f92672">(</span>G<span style="color:#f92672">)</span>
          d<span style="color:#f92672">(</span>v<span style="color:#f92672">)</span> :<span style="color:#f92672">=</span> ∞
      d<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span> :<span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
      offer s into Q
      <span style="color:#66d9ef">while</span> Q is not empty
          u :<span style="color:#f92672">=</span> poll Q
          <span style="color:#66d9ef">for</span> each edge <span style="color:#f92672">(</span>u, v<span style="color:#f92672">)</span> in E<span style="color:#f92672">(</span>G<span style="color:#f92672">)</span>
              <span style="color:#66d9ef">if</span> d<span style="color:#f92672">(</span>u<span style="color:#f92672">)</span> + w<span style="color:#f92672">(</span>u, v<span style="color:#f92672">)</span> &lt; d<span style="color:#f92672">(</span>v<span style="color:#f92672">)</span> <span style="color:#66d9ef">then</span>
                  d<span style="color:#f92672">(</span>v<span style="color:#f92672">)</span> :<span style="color:#f92672">=</span> d<span style="color:#f92672">(</span>u<span style="color:#f92672">)</span> + w<span style="color:#f92672">(</span>u, v<span style="color:#f92672">)</span>
                  <span style="color:#66d9ef">if</span> v is not in Q <span style="color:#66d9ef">then</span>
                      offer v into Q
</code></pre></div><p><a href="http://codeforces.com/blog/entry/16221">http://codeforces.com/blog/entry/16221</a> :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">SPFA(v):
	d[i] <span style="color:#f92672">=</span> inf <span style="color:#66d9ef">for</span> each vertex i
	d[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
	queue q
	q<span style="color:#f92672">.</span>push(v)
	<span style="color:#66d9ef">while</span> q <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> empty
		u <span style="color:#f92672">=</span> q<span style="color:#f92672">.</span>front()
		q<span style="color:#f92672">.</span>pop()
		<span style="color:#66d9ef">for</span> each i <span style="color:#f92672">in</span> adj[u]
			<span style="color:#66d9ef">if</span> d[i] <span style="color:#f92672">&gt;</span> d[u] <span style="color:#f92672">+</span> w(u,i)
				then d[i] <span style="color:#f92672">=</span> d[u] <span style="color:#f92672">+</span> w(u,i)
				<span style="color:#66d9ef">if</span> i <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> q
					then q<span style="color:#f92672">.</span>push(i)
</code></pre></div><h1 id="references">References</h1>
<ul>
<li>
<p><a href="http://codeforces.com/blog/entry/16221">Algorithm Gym :: Graph Algorithms</a></p>
</li>
<li>
<p><a href="http://codeforces.com/">http://codeforces.com/</a></p>
</li>
</ul>
</div>
            <aside id="meta">
                
            </aside>
            </div>
        <div class="bg-white dark:bg-warmgray-900 p-5 my-4">
            <div class="grid grid-cols-2">
                <div class="col-span-1">
                    
                    <a class="previous lg:text-2xl" href="https://milaiai.com/post/ch3.3.1-%E7%BB%98%E5%88%B6landmark/">
                        <div
                            class="transition-colors duration-300 border border-gray-600 hover:border-black h-auto m-3 text-center py-3 lg:py-1">
                            <span class="icon-keyboard_arrow_left"></span> 绘制Landmark
                        </div>
                    </a>
                    
                </div>
                
                <a class="next lg:text-2xl" href="https://milaiai.com/post/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">
                    <div
                        class="transition-colors duration-300 col-span-1 border border-gray-600 hover:border-black h-auto m-3 text-center py-3 lg:py-1">
                        算法-动态规划 <span class="icon-keyboard_arrow_right"></span>
                    </div>
                </a>
                
            </div>
        </div>
        <div class="bg-white dark:bg-warmgray-900 p-5 my-4">
            <div class="mb-3">
                
            </div>
        </div>
    </div>
    
</div>

            </div>
        </div><footer class="bg-gray-800 text-white p-6">
    
    <div class="container mr-auto ml-auto">
        <p>&copy; 2022 <a href="https://milaiai.com/" class="hover:text-gray-500">MILAI AI</a></p>
        <p>Powered by <a href="https://gohugo.io/" class="hover:text-gray-500">Hugo</a>, Theme <a
                href="https://github.com/opera7133/Blonde" class="hover:text-gray-500">Blonde</a>.</p>
    </div>
    <script src="/js/switch.js"></script>

    <script src='http://cdn.mathjax.org/mathjax/latest/MathJax.js' type='text/javascript'>    
    MathJax.Hub.Config({
        HTML: ["input/TeX","output/HTML-CSS"],
        TeX: { extensions: ["AMSmath.js","AMSsymbols.js"],
               equationNumbers: { autoNumber: "AMS" } },
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: { inlineMath: [ ['$','$'] ],
                   displayMath: [ ['$$','$$']  ],
                   processEscapes: true
                  },
        "HTML-CSS": { availableFonts: ["TeX"],
                      linebreaks: { automatic: true } }
    });</script>
</footer>
</div>
</body>

</html>
